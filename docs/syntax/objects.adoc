---
layout: default
title: Objects
parent: Language Syntax
nav_order: 2
---

== Objects

Understanding PostScript objects and their attributes.

=== Overview

In PostScript, everything is an **object**. Objects are the fundamental data entities that the PostScript interpreter manipulates. Each object has a **type** and may have **attributes** that control how it behaves.

=== Object Types

PostScript defines several fundamental object types:

==== Simple Objects

**Integer**:: Whole numbers in the range -2³¹ to 2³¹-1
+
[source,postscript]
----
42  -17  0  2147483647
----

**Real**:: Floating-point numbers with approximately 7 significant digits
+
[source,postscript]
----
3.14  -0.5  6.02e23  1.0E-10
----

**Boolean**:: Logical true or false values
+
[source,postscript]
----
true  false
----

**Name**:: Identifiers used to reference other objects
+
[source,postscript]
----
/Times-Roman  /x  /myproc
----

**Null**:: A special object representing no value
+
[source,postscript]
----
null
----

==== Composite Objects

**String**:: Sequence of bytes, typically representing text
+
[source,postscript]
----
(Hello, World!)
<48656C6C6F>  % Hexadecimal string
----

**Array**:: Ordered collection of objects
+
[source,postscript]
----
[1 2 3]
[/name 42 (text)]
----

**Dictionary**:: Associative array mapping keys to values
+
[source,postscript]
----
<< /FontName /Times-Roman /FontSize 12 >>
----

**Procedure**:: Executable array (code block)
+
[source,postscript]
----
{ dup mul }  % Square a number
----

==== Special Objects

**Mark**:: Stack delimiter used in array construction
+
[source,postscript]
----
mark  % or equivalently [
----

**Operator**:: Built-in PostScript command
+
[source,postscript]
----
add  sub  moveto  show
----

**File**:: Input/output stream
+
[source,postscript]
----
currentfile
(myfile.ps) (r) file
----

**Save**:: VM snapshot for state restoration
+
[source,postscript]
----
save  % Returns save object
----

**Font**:: Character shape collection
+
[source,postscript]
----
/Times-Roman findfont  % Returns font dictionary
----

=== Object Attributes

Each object has attributes that control its behavior:

==== Literal vs. Executable

**Literal**:: The object represents itself
+
[source,postscript]
----
/name      % Literal name
(text)     % Literal string
[1 2 3]    % Literal array
----

**Executable**:: The object is executed when encountered
+
[source,postscript]
----
name       % Executable name (looks up and executes)
{ add }    % Executable array (procedure)
----

Convert between literal and executable:

[source,postscript]
----
/name cvx      % Make name executable
{ code } cvlit % Make procedure literal
----

==== Access Attributes

**No Access**:: Cannot be accessed
**Read-Only**:: Can be read but not modified
**Execute-Only**:: Can only be executed (for arrays)
**Unlimited**:: Can be read, written, and executed

Check and modify access:

[source,postscript]
----
dict rcheck       % Check if readable
dict wcheck       % Check if writable
dict xcheck       % Check if executable
dict readonly     % Make read-only
dict executeonly  % Make execute-only (arrays)
----

=== Type Checking

Get an object's type:

[source,postscript]
----
42 type         % Returns: /integertype
3.14 type       % Returns: /realtype
(text) type     % Returns: /stringtype
[1 2 3] type    % Returns: /arraytype
{ add } type    % Returns: /arraytype (procedures are arrays)
/name type      % Returns: /nametype
true type       % Returns: /booleantype
null type       % Returns: /nulltype
----

=== Type Conversion

Convert between types:

[source,postscript]
----
% String to number
(42) cvi        % String to integer: 42
(3.14) cvr      % String to real: 3.14

% Number to string
42 20 string cvs    % Integer to string: (42)

% String to name
(myname) cvn    % String to name: /myname

% Name to string
/myname 20 string cvs  % Name to string: (myname)

% Integer to real
42 cvr          % Integer to real: 42.0

% Real to integer
3.14 cvi        % Real to integer: 3 (truncated)
----

=== Object Equality

PostScript has two notions of equality:

**Value Equality** (link:/commands/references/eq/[`eq`]):: Objects have the same value
+
[source,postscript]
----
3 3 eq          % true
(abc) (abc) eq  % false (different string objects)
----

**Identity Equality** (link:/commands/references/eq/[`eq`] for simple types):: Objects are the same object
+
[source,postscript]
----
/arr [1 2 3] def
arr arr eq      % true (same array)
arr [1 2 3] eq  % false (different arrays, same values)
----

For composite objects, link:/commands/references/eq/[`eq`] tests object identity, not value equality.

=== Object Sharing

Composite objects can be shared:

[source,postscript]
----
/arr1 [1 2 3] def
/arr2 arr1 def      % arr2 and arr1 refer to same array
arr1 0 99 put       % Modifies both arr1 and arr2
arr1 ==             % [99 2 3]
arr2 ==             % [99 2 3] (same object)
----

Copy to create independent objects:

[source,postscript]
----
/arr1 [1 2 3] def
/arr2 arr1 length array def
arr1 arr2 copy pop  % Create independent copy
arr1 0 99 put       % Only modifies arr1
arr1 ==             % [99 2 3]
arr2 ==             % [1 2 3] (different object)
----

=== Object Memory Management

**Local VM**:: Objects allocated here are temporary
+
[source,postscript]
----
save
  /local [1 2 3] def  % Local allocation
restore                 % local is discarded
----

**Global VM**:: Objects persist across save/restore
+
[source,postscript]
----
true setglobal
/global [1 2 3] def  % Global allocation
false setglobal
----

=== Common Patterns

==== Type Testing

[source,postscript]
----
/isarray {  % obj => bool
  type /arraytype eq
} def

/isstring {  % obj => bool
  type /stringtype eq
} def
----

==== Safe Type Conversion

[source,postscript]
----
/safeint {  % obj => int or obj
  dup type /stringtype eq {
    cvi
  } if
} def
----

==== Object Copying

[source,postscript]
----
/copyobject {  % obj => obj_copy
  dup type dup
  /arraytype eq {
    pop dup length array copy
  } {
    /stringtype eq {
      dup length string copy
    } {
      % Simple types are values, no copy needed
    } ifelse
  } ifelse
} def
----

=== Best Practices

TIP: *Check Types* - Use link:/commands/references/type/[`type`] and comparison to validate object types before operations.

TIP: *Be Aware of Sharing* - Remember that assignment creates references, not copies, for composite objects.

TIP: *Use Appropriate Access* - Set proper access attributes to prevent unintended modifications.

WARNING: *Type Errors* - Operating on wrong types causes [`typecheck`] errors. Always validate types for robustness.

=== See Also

* link:/syntax/data-types/[Data Types]
* link:/syntax/arrays/[Arrays]
* link:/syntax/strings/[Strings]
* link:/syntax/dictionaries/[Dictionaries]
* link:/commands/references/type/[type command]
* link:/commands/references/cvx/[cvx command]
* link:/commands/references/cvlit/[cvlit command]
