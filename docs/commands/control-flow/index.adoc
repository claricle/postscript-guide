---
layout: default
title: Control Flow
parent: Commands
nav_order: 5
---

== Control Flow

Control flow operations enable conditional execution, loops, and program flow control in PostScript. These commands provide the foundation for decision-making and repetitive operations.

== Overview

PostScript control flow operates through:

* **Conditional execution**: Execute code based on boolean conditions
* **Iteration**: Repeat operations multiple times or over collections
* **Flow control**: Exit loops early, handle errors, terminate execution
* **Dynamic execution**: Execute objects programmatically

== Command Categories

=== Conditional Execution

[cols="1,3"]
|===
| Command | Description

| link:/commands/references/if/[`if`]
| Execute procedure if condition is true

| link:/commands/references/ifelse/[`ifelse`]
| Execute one of two procedures based on condition
|===

=== Iteration

[cols="1,3"]
|===
| Command | Description

| link:/commands/references/for/[`for`]
| Loop with numeric control variable

| link:/commands/references/repeat/[`repeat`]
| Execute procedure a fixed number of times

| link:/commands/references/loop/[`loop`]
| Execute procedure indefinitely until exit

| link:/commands/references/forall/[`forall`]
| Iterate over array, string, or dictionary elements
|===

=== Flow Control

[cols="1,3"]
|===
| Command | Description

| link:/commands/references/exit/[`exit`]
| Terminate innermost loop early

| link:/commands/references/stop/[`stop`]
| Terminate stopped context

| link:/commands/references/stopped/[`stopped`]
| Execute object with error catching

| link:/commands/references/quit/[`quit`]
| Terminate interpreter
|===

=== Dynamic Execution

[cols="1,3"]
|===
| Command | Description

| link:/commands/references/exec/[`exec`]
| Execute an object

| link:/commands/references/cvx/[`cvx`]
| Convert to executable attribute
|===

== Common Patterns

=== Conditional Execution

[source,postscript]
----
% Simple conditional
x 0 gt {
  (positive) print
} if

% Two-way conditional
x 0 gt {
  (positive) print
} {
  (non-positive) print
} ifelse
----

=== Numeric Iteration

[source,postscript]
----
% Count from 1 to 10
1 1 10 {
  % Loop body, current value on stack
  =
} for

% Count down
10 -1 1 {
  % 10, 9, 8, ..., 1
} for
----

=== Collection Iteration

[source,postscript]
----
% Process array elements
[1 2 3 4 5] {
  10 mul  % Multiply each by 10
} forall

% Process string characters
(hello) {
  % Each character code pushed
  =
} forall
----

=== Error Handling

[source,postscript]
----
{
  % Code that might fail
  riskyOperation
} stopped {
  % Handle error
  (Operation failed) print
} if
----

== Loop Types Comparison

[cols="2,3,2"]
|===
| Loop Type | Use When | Control Variable

| link:/commands/references/for/[`for`]
| Numeric sequence needed
| Yes

| link:/commands/references/repeat/[`repeat`]
| Simple fixed repetition
| No

| link:/commands/references/loop/[`loop`]
| Indefinite looping
| No

| link:/commands/references/forall/[`forall`]
| Iterating collections
| Yes (element)
|===

== Important Considerations

=== Boolean Context

Conditionals require boolean values:

[source,postscript]
----
true { } if      % Correct
0 { } if         % Error: typecheck (0 is not boolean)
----

=== Procedure Objects

Control flow operators require procedures (executable arrays):

[source,postscript]
----
{ code } if      % Correct: { } creates procedure
[code] if        % Wrong: [ ] creates literal array
----

=== Loop Termination

* link:/commands/references/exit/[`exit`] exits innermost loop only
* link:/commands/references/stop/[`stop`] exits stopped context
* Infinite loops possible with link:/commands/references/loop/[`loop`]

=== Stack Effects

Procedures may leave values on stack:

[source,postscript]
----
5 { 10 } repeat  % Leaves 10 10 10 10 10 on stack
5 { } repeat     % Leaves nothing
----

== Common Pitfalls

WARNING: *Not C-Style Booleans* - PostScript uses true/false, not 0/1 or nil/non-nil.

WARNING: *Procedures Not Blocks* - Use `{ }` not `[ ]` for code blocks.

WARNING: *Stack Accumulation* - Loop bodies that don't consume values will accumulate on stack.

TIP: *Use exit Carefully* - Only works within loop contexts (for, repeat, loop, forall).

== See Also

* link:/commands/references/[Dictionary Operations] - For scoping with begin/end
* link:/commands/array-string/[Array Operations] - For forall iteration
* Error Handling (to be documented) - For comprehensive error management