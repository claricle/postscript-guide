---
layout: default
title: idtransform
parent: Coordinate Transformations
grand_parent: Command Reference
nav_order: 16
---

== idtransform

Transforms a distance vector from device space to user space (inverse delta transform).

=== Syntax

----
dx' dy' idtransform → dx dy
dx' dy' matrix idtransform → dx dy
----

=== Stack Effects

.Before
[cols="1,3"]
|===
| Level | Object

| 1
| `dy'` (number)

| 0
| `dx'` (number)
|===

.After
[cols="1,3"]
|===
| Level | Object

| 1
| `dy` (number)

| 0
| `dx` (number)
|===

=== Description

With no matrix operand, xref:../idtransform.adoc[`idtransform`] (inverse delta transform) transforms the device space distance vector (dx', dy') by the inverse of the CTM to produce the corresponding distance vector (dx, dy) in user space.

If the `matrix` operand is supplied, xref:../idtransform.adoc[`idtransform`] transforms the distance vector by the inverse of `matrix` rather than by the inverse of CTM.

A delta transformation is similar to a normal transformation, but the translation components (tx and ty) of the transformation matrix are not used, making the distance vectors position-independent in both user space and device space.

xref:../idtransform.adoc[`idtransform`] is the inverse of xref:../dtransform.adoc[`dtransform`]. It is useful for determining how distances map from device space to user space.

=== PostScript Level

*Level 1* and later

=== Examples

.Basic inverse delta transformation
[source,postscript]
----
2 2 scale
100 200 dtransform
% → 200.0 400.0

200 400 idtransform
% → 100.0 200.0 (back to original)
----

.Translation ignored
[source,postscript]
----
100 100 translate
2 2 scale

% Distance transformation ignores translation
100 100 idtransform
% → 50.0 50.0 (only scaling reversed)
----

.Device pixel size
[source,postscript]
----
72 72 scale  % 72 points per inch
1 1 idtransform
% → 0.0138... 0.0138... (1 pixel ≈ 1/72 inch)
----

=== Common Use Cases

==== Converting Device Units to User Units

[source,postscript]
----
% How much is 1 device pixel in user space?
2 2 scale
1 0 idtransform pop
% → 0.5 (1 device pixel = 0.5 user units)
----

==== Computing User Space Line Width

[source,postscript]
----
% What line width in user space gives 1 device pixel?
/deviceLineWidth 1 def
deviceLineWidth 0 idtransform abs exch abs max
setlinewidth
% Now line appears as 1 device pixel regardless of scale
----

==== Measuring in Device Units

[source,postscript]
----
% How many device pixels in 10 user units?
10 0 dtransform abs
% Then convert back to understand scale:
dup 0 exch idtransform abs
% Returns 10.0 (round-trip)
----

==== Stroke Width Adjustment

[source,postscript]
----
% Ensure minimum line width in device space
/minDeviceWidth 1 def  % At least 1 pixel
currentlinewidth 0 dtransform abs
minDeviceWidth lt {
  % Line is too thin, adjust
  minDeviceWidth 0 idtransform abs
  setlinewidth
} if
----

=== Common Pitfalls

WARNING: *For Distances Only* - xref:../idtransform.adoc[`idtransform`] is for distance vectors, not positions.

[source,postscript]
----
100 100 translate
2 2 scale

% Wrong - for point coordinates:
300 400 idtransform  % → 150 200 (incorrect)
300 400 itransform   % → 100 150 (correct)

% Right - for distances:
200 400 idtransform  % → 100 200 (correct distance)
----

WARNING: *Singular Matrices* - If CTM or matrix is singular, xref:../idtransform.adoc[`idtransform`] fails.

[source,postscript]
----
0 0 scale  % Singular matrix (determinant = 0)
100 100 idtransform  % Error: undefinedresult
----

WARNING: *Different from itransform* - These are not the same!

[source,postscript]
----
100 100 translate
100 100 itransform   % → 0 0 (point transformation)
100 100 idtransform  % → 100 100 (distance transformation)
----

TIP: *Use for Scale-Independent Sizing* - Compute sizes that remain constant in device space:

[source,postscript]
----
% Draw circle with fixed device radius
/drawDeviceCircle {  % deviceRadius
  0 exch idtransform  % Convert to user space
  /radiusY exch def
  /radiusX exch def
  % Draw ellipse if non-uniform scaling
  0 0 radiusX radiusY scale
  0 0 1 0 360 arc
} def

5 drawDeviceCircle  % Always 5 device pixels radius
----

TIP: *Round-Trip Testing* - Verify inverse relationship:

[source,postscript]
----
/testDelta {  % dx dy
  2 copy dtransform idtransform
  3 -1 roll sub abs 0.001 lt
  3 1 roll exch sub abs 0.001 lt and
} def

100 200 testDelta  % Should return true
----

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`rangecheck`]
| Matrix operand does not have exactly 6 elements

| [`stackunderflow`]
| Fewer than 2 operands on stack (first form) or fewer than 3 (second form)

| [`typecheck`]
| Operands are not numbers, or matrix operand is not an array

| [`undefinedresult`]
| CTM or matrix is singular (determinant = 0) and cannot be inverted
|===

=== Implementation Notes

* More expensive than xref:../dtransform.adoc[`dtransform`] (requires inverse computation)
* Translation components are explicitly ignored
* The inverse uses only [a b c d] components
* Precision depends on matrix condition number
* No caching of inverse matrix

=== Transformation Formula

For CTM = [a b c d tx ty], the inverse delta transformation is:

----
det = a×d - b×c

dx = (d×dx' - c×dy') / det
dy = (a×dy' - b×dx') / det
----

Note: tx and ty are not used.

Example with CTM = [2 0 0 3 100 100]:

----
det = 2×3 - 0×0 = 6

(20, 60) inverse delta transforms to:
dx = (3×20 - 0×60) / 6 = 60/6 = 10
dy = (2×60 - 0×20) / 6 = 120/6 = 20
→ (10, 20)
----

=== Delta Transform Pairs

[cols="2,3,3"]
|===
| Operation | Direction | Translation

| xref:../dtransform.adoc[`dtransform`]
| User → Device
| Ignored

| xref:../idtransform.adoc[`idtransform`]
| Device → User
| Ignored

| xref:../transform.adoc[`transform`]
| User → Device
| Included

| xref:../itransform.adoc[`itransform`]
| Device → User
| Included
|===

=== Computing Device Pixel Size

[source,postscript]
----
% Determine size of device pixel in current user space
/getPixelSize {
  % Returns width and height of device pixel
  1 0 idtransform abs exch abs  % X direction
  0 1 idtransform abs exch abs  % Y direction
} def

2 3 scale
getPixelSize
% → 0.5 0.333... (pixel is 0.5×0.333 user units)
----

=== Relationship to Graphics Parameters

Many graphics parameters are affected by transformations:

[source,postscript]
----
% Line width:
% User space width → dtransform → device width
% Device width → idtransform → user space width

% Dash pattern:
% User space lengths → dtransform → device lengths
% Device lengths → idtransform → user space lengths

% Character widths:
% Font space → dtransform → device pixels
% Device pixels → idtransform → font space
----

=== Performance Considerations

* Requires matrix inversion computation
* More expensive than xref:../dtransform.adoc[`dtransform`]
* Still very fast for occasional use
* Consider caching inverse matrix for repeated use:

[source,postscript]
----
% Inefficient:
{
  deviceDX deviceDY idtransform
  % ... process ...
} repeat

% Efficient:
matrix currentmatrix matrix invertmatrix
/inverseMatrix exch def
{
  deviceDX deviceDY inverseMatrix dtransform
  % ... process ...
} repeat
----

=== See Also

* xref:../dtransform.adoc[`dtransform`] - Transform distance vector (forward)
* xref:../transform.adoc[`transform`] - Transform coordinates (includes translation)
* xref:../itransform.adoc[`itransform`] - Inverse coordinate transformation
* xref:../invertmatrix.adoc[`invertmatrix`] - Invert transformation matrix
* xref:../currentmatrix.adoc[`currentmatrix`] - Get current CTM
* xref:../graphics-state/setlinewidth.adoc[`setlinewidth`] - Set line width