---
layout: default
title: invertmatrix
parent: Coordinate Transformations
grand_parent: Command Reference
nav_order: 12
---

== invertmatrix

Computes the inverse of a transformation matrix.

=== Syntax

----
matrix1 matrix2 invertmatrix → matrix2
----

=== Stack Effects

.Before
[cols="1,3"]
|===
| Level | Object

| 1
| `matrix1` (6-element array)

| 0
| `matrix2` (6-element array)
|===

.After
[cols="1,3"]
|===
| Level | Object

| 0
| `matrix2` (modified array)
|===

=== Description

link:invertmatrix.adoc[`invertmatrix`] replaces the value of `matrix2` with the inverse of `matrix1` and pushes the modified `matrix2` back on the operand stack.

The inverse matrix has the property that if `matrix1` transforms a coordinate (x, y) to (x', y'), then `matrix2` transforms (x', y') back to (x, y).

Mathematically: M₁ × M₂ = M₂ × M₁ = I (identity matrix)

If `matrix1` is singular (determinant = 0), link:invertmatrix.adoc[`invertmatrix`] executes an [`undefinedresult`] error because the inverse does not exist.

=== PostScript Level

*Level 1* and later

=== Examples

.Inverting a translation
[source,postscript]
----
/forward matrix 100 200 translate def
/inverse matrix def
forward inverse invertmatrix
% inverse = [1 0 0 1 -100 -200]
% Translates by (-100, -200)
----

.Inverting a scale
[source,postscript]
----
/scale2x matrix 2 2 scale def
/scale_half matrix def
scale2x scale_half invertmatrix
% scale_half = [0.5 0 0 0.5 0 0]
% Scales by 1/2
----

.Inverting a rotation
[source,postscript]
----
/rot45 matrix 45 rotate def
/rot_neg45 matrix def
rot45 rot_neg45 invertmatrix
% rot_neg45 rotates by -45 degrees
----

=== Common Use Cases

==== Undoing Transformations

[source,postscript]
----
% Apply transformation
/myTransform [2 0 0 2 100 100] def
myTransform concat

% Compute inverse
/myInverse matrix def
myTransform myInverse invertmatrix

% Undo transformation
myInverse concat
% Back to original coordinate system
----

==== Coordinate Space Conversion

[source,postscript]
----
% Transform from device to user space
matrix currentmatrix /ctm exch def
/inverseCTM matrix def
ctm inverseCTM invertmatrix

% Now can transform device coordinates to user coordinates
% using inverseCTM with transform operator
----

==== Building Inverse Transformations

[source,postscript]
----
% Create matched pair of transformations
/setupTransform {
  % Build forward transformation
  /forward matrix def
  forward 100 100 translate
  forward 2 2 scale
  forward 45 rotate

  % Build inverse
  /inverse matrix def
  forward inverse invertmatrix
} def
----

=== Common Pitfalls

WARNING: *Singular Matrices* - Matrices with zero determinant cannot be inverted.

[source,postscript]
----
% This matrix has determinant = 0
[2 4 1 2 0 0] invertmatrix  % Error: undefinedresult
% Because: (2×2) - (4×1) = 0
----

WARNING: *Numerical Precision* - Very large or very small matrix values can cause precision loss.

[source,postscript]
----
% Extreme values may lose precision
[1000000 0 0 1000000 0 0] invertmatrix
% Inverse has very small values (0.000001)
% May experience rounding errors
----

WARNING: *Order of Application* - The inverse undoes transformations in reverse order.

[source,postscript]
----
% Forward: translate then scale
matrix 100 100 translate 2 2 scale

% Inverse: scale⁻¹ then translate⁻¹
% (automatically computed by invertmatrix)
----

TIP: *Check Validity Before Inverting* - Verify matrix is non-singular:

[source,postscript]
----
% Compute determinant
/checkMatrix {  % matrix -> bool
  dup 0 get exch dup 3 get mul  % a×d
  exch dup 1 get exch 2 get mul % b×c
  sub                            % a×d - b×c
  0 ne                           % determinant ≠ 0
} def

myMatrix checkMatrix {
  myMatrix inverse invertmatrix
} if
----

TIP: *Use for Coordinate Conversion* - Primary use is with xref:itransform.adoc[`itransform`] and xref:idtransform.adoc[`idtransform`]:

[source,postscript]
----
% Manual inverse transformation
matrix currentmatrix /ctm exch def
/inv matrix def
ctm inv invertmatrix
% Now can use inv with transform for inverse effect
----

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`rangecheck`]
| Either array has fewer than 6 elements

| [`stackunderflow`]
| Fewer than 2 operands on stack

| [`typecheck`]
| Operands are not arrays, or array elements are not all numbers

| [`undefinedresult`]
| `matrix1` is singular (determinant = 0) and cannot be inverted
|===

=== Implementation Notes

* The inverse is computed using standard matrix inversion
* Numerical stability depends on matrix condition number
* Well-conditioned matrices invert accurately
* Ill-conditioned matrices may experience precision loss
* The determinant must be non-zero for inversion to succeed

=== Matrix Mathematics

For matrix M = [a b c d tx ty], the inverse M⁻¹ is:

----
det = a×d - b×c  (determinant)
----

If det ≠ 0:

----
M⁻¹ = [d/det  -b/det  -c/det  a/det
       (c×ty - d×tx)/det  (b×tx - a×ty)/det]
----

Properties of inverse:

* M × M⁻¹ = M⁻¹ × M = I (identity)
* (M⁻¹)⁻¹ = M
* (M₁ × M₂)⁻¹ = M₂⁻¹ × M₁⁻¹

=== Special Cases

==== Identity Matrix Inverse

[source,postscript]
----
[1 0 0 1 0 0] invertmatrix
% → [1 0 0 1 0 0]
% Identity is its own inverse
----

==== Translation Inverse

[source,postscript]
----
[1 0 0 1 100 200] invertmatrix
% → [1 0 0 1 -100 -200]
% Inverse translates by negative amounts
----

==== Scale Inverse

[source,postscript]
----
[2 0 0 3 0 0] invertmatrix
% → [0.5 0 0 0.333... 0 0]
% Inverse scales by reciprocals
----

==== Rotation Inverse

[source,postscript]
----
% 45° rotation:
[0.707 0.707 -0.707 0.707 0 0] invertmatrix
% → [0.707 -0.707 0.707 0.707 0 0]
% -45° rotation (same as transpose for rotation)
----

=== Determinant

The determinant indicates if a matrix is invertible:

[source,postscript]
----
/determinant {  % matrix -> number
  dup 0 get exch dup 3 get mul  % a×d
  exch dup 1 get exch 2 get mul % b×c
  sub                            % a×d - b×c
} def

myMatrix determinant 0 eq {
  (Matrix is singular!) print
} {
  (Matrix is invertible) print
} ifelse
----

=== Performance Considerations

* Matrix inversion is computationally intensive
* More expensive than matrix multiplication
* Avoid inverting repeatedly; compute once and reuse
* Well-conditioned matrices invert faster

=== Relationship to Transform Operators

link:invertmatrix.adoc[`invertmatrix`] is used with inverse transformation operators:

[source,postscript]
----
% Forward transformation
/fwd matrix currentmatrix def
100 200 fwd transform  % User to device

% Inverse transformation
/inv matrix def
fwd inv invertmatrix
100 200 inv itransform % Device to user
----

=== See Also

* xref:concatmatrix.adoc[`concatmatrix`] - Multiply two matrices
* xref:itransform.adoc[`itransform`] - Inverse coordinate transformation
* xref:idtransform.adoc[`idtransform`] - Inverse distance transformation
* xref:currentmatrix.adoc[`currentmatrix`] - Get current CTM
* xref:matrix.adoc[`matrix`] - Create identity matrix