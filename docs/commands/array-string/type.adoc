---
layout: default
title: type
parent: Array and String Operations
grand_parent: Command Reference
nav_order: 23
---

== type

Returns a name identifying the type of an object.

=== Syntax

----
any type â†’ name
----

=== Stack Effects

.Before
[cols="1,3"]
|===
| Level | Object

| 0
| `any` (any object)
|===

.After
[cols="1,3"]
|===
| Level | Object

| 0
| `name` (executable name identifying type)
|===

=== Description

xref:../type.adoc[`type`] returns a name object that identifies the type of its operand. The returned name has the **executable** attribute, making it convenient for type-dependent processing via dictionary lookup.

=== PostScript Level

*Level 1* and later

=== Type Names

[cols="2,3"]
|===
| Object Type | Returned Name

| Array
| `arraytype`

| Boolean
| `booleantype`

| Dictionary
| `dicttype`

| File
| `filetype`

| Font (fontID)
| `fonttype`

| Graphics state
| `gstatetype`

| Integer
| `integertype`

| Lock (DPS)
| `locktype`

| Mark
| `marktype`

| Name
| `nametype`

| Null
| `nulltype`

| Operator
| `operatortype`

| Packed array
| `packedarraytype`

| Real
| `realtype`

| Save object
| `savetype`

| String
| `stringtype`

| Condition (DPS)
| `conditiontype`
|===

=== Examples

.Basic type checking
[source,postscript]
----
123 type         % Result: integertype
3.14 type        % Result: realtype
(text) type      % Result: stringtype
/name type       % Result: nametype
[1 2 3] type     % Result: arraytype
----

.Type-dependent processing
[source,postscript]
----
5 dict begin
  /integertype { (Integer: ) print = } def
  /realtype { (Real: ) print = } def
  /stringtype { (String: ) print = } def

  42 dup type exec      % Prints "Integer: 42"
  3.14 dup type exec    % Prints "Real: 3.14"
end
----

.Distinguishing arrays
[source,postscript]
----
[1 2 3] type /arraytype eq        % true
1 2 3 3 packedarray type /packedarraytype eq  % true
----

=== Common Use Cases

==== Type Validation

[source,postscript]
----
/validateNumber {
  dup type dup
  /integertype eq
  exch /realtype eq or not {
    /typecheck cvx exec
  } if
} def
----

==== Generic Processing

[source,postscript]
----
/typeHandlers 10 dict def
typeHandlers /integertype { handle-int } put
typeHandlers /stringtype { handle-str } put

/process {
  dup type typeHandlers exch get exec
} def
----

==== Debugging

[source,postscript]
----
/showtype {
  dup type 20 string cvs print
  ( : ) print =
} def

123 showtype         % Prints "integertype : 123"
----

=== Common Pitfalls

WARNING: *Font vs. Dictionary* - A font dictionary returns `dicttype`, not `fonttype`. Only fontID objects return `fonttype`.

[source,postscript]
----
/Helvetica findfont type  % dicttype
----

WARNING: *Executable Name* - The returned name is executable, which affects how it's processed.

[source,postscript]
----
123 type          % Pushes executable 'integertype'
% If executed, looks up in dictionary
----

TIP: *Future Types* - The set of types may expand in future PostScript versions. Handle unknown types gracefully.

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`stackunderflow`]
| No operand on stack
|===

=== Implementation Notes

* Very fast operation (type stored with object)
* Returns executable name for dictionary-based dispatch
* Type names defined in `systemdict`
* Useful for polymorphic operators

=== Type Hierarchy

PostScript has no formal inheritance, but types can be categorized:

* **Simple types**: integer, real, boolean, null, mark
* **Composite types**: array, packedarray, string, dictionary
* **Reference types**: name, operator, save, gstate, font, file
* **Synchronization** (DPS): lock, condition

=== See Also

* xref:../cvlit.adoc[`cvlit`] - Convert to literal
* xref:../cvx.adoc[`cvx`] - Convert to executable
* xref:../xcheck.adoc[`xcheck`] - Test if executable
* xref:../rcheck.adoc[`rcheck`] - Test if readable
* xref:../wcheck.adoc[`wcheck`] - Test if writable