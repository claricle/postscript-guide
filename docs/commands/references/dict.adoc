---
layout: default
title: dict
parent: Command Reference
nav_order: 1
---

== dict

Creates a new empty dictionary with specified initial capacity.

=== Syntax

----
int dict â†’ dict
----

=== Stack Effects

.Before
[cols="1,3"]
|===
| Level | Object

| 0
| `int` (non-negative integer)
|===

.After
[cols="1,3"]
|===
| Level | Object

| 0
| `dict` (new empty dictionary)
|===

=== Description

link:/docs/commands/references/dict/[`dict`] creates an empty dictionary with an initial capacity of _int_ elements and pushes it onto the operand stack.

**Level 1**: The dictionary has a fixed maximum capacity of _int_ elements. Attempting to exceed this causes [`dictfull`] error.

**Level 2**: The _int_ operand specifies only the initial capacity; the dictionary can grow automatically beyond that if needed.

The dictionary is allocated in local or global VM according to the current VM allocation mode.

=== PostScript Level

*Level 1* and later

=== Examples

.Basic dictionary creation
[source,postscript]
----
5 dict  % Create dictionary with capacity for 5 entries
----

.Create and populate
[source,postscript]
----
10 dict begin
  /name (PostScript) def
  /version 2 def
  /active true def
end
----

.Dictionary for configuration
[source,postscript]
----
/config 20 dict def
config /fontSize 12 put
config /fontName /Helvetica put
----

=== Common Use Cases

==== Local Variable Scope

[source,postscript]
----
/myFunction {
  5 dict begin
    /localVar1 10 def
    /localVar2 20 def
    % Use local variables
    localVar1 localVar2 add
  end
} def
----

==== Configuration Storage

[source,postscript]
----
/settings 50 dict def
settings begin
  /margin 72 def
  /pageWidth 612 def
  /pageHeight 792 def
end
----

=== Common Pitfalls

WARNING: *Size Matters in Level 1* - In Level 1, choose _int_ large enough for all entries. Exceeding capacity causes [`dictfull`].

[source,postscript]
----
% Level 1
2 dict begin
  /key1 1 def
  /key2 2 def
  /key3 3 def  % Error: dictfull
end
----

WARNING: *Growing Costs in Level 2* - Even in Level 2, growing a dictionary consumes additional VM and has performance costs.

TIP: *Choose Appropriate Size* - Estimate needed size to avoid expensive expansion:
* Small dictionaries: 5-10 entries
* Medium dictionaries: 20-50 entries
* Large dictionaries: 100+ entries

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`limitcheck`]
| _int_ exceeds implementation limits

| [`stackunderflow`]
| No operand on stack

| [`typecheck`]
| Operand is not an integer

| [`VMerror`]
| Insufficient VM to allocate dictionary
|===

=== Implementation Notes

**Level 1:**
* Fixed capacity set at creation
* Cannot exceed _int_ entries
* Simple hash table implementation

**Level 2:**
* Initial capacity of _int_
* Auto-expands when needed
* Expansion in chunks for efficiency
* May contain unused space after expansion

=== Performance Considerations

* Choose initial size wisely to avoid expansion
* Expansion is expensive (rehashing required)
* Small initial size OK if final size unknown
* Large initial size wastes VM if unused

=== Standard Dictionaries

[cols="2,3"]
|===
| Dictionary | Purpose

| `systemdict`
| Read-only system operators and definitions

| `globaldict`
| Global definitions (Level 2)

| `userdict`
| User definitions (writable)

| `errordict`
| Error handling procedures

| `$error`
| Error state information

| `statusdict`
| Product-specific information
|===

=== See Also

* link:/docs/commands/references/begin/[`begin`] - Push dict onto dict stack
* link:/docs/commands/references/end/[`end`] - Pop dict from dict stack
* link:/docs/commands/references/def/[`def`] - Define entry in current dict
* link:/docs/commands/references/maxlength/[`maxlength`] - Get maximum capacity
* link:/docs/commands/references/length/[`length`] - Get current entry count