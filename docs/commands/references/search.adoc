---
layout: default
title: search
parent: Command Reference
nav_order: 15
---

== search

Searches for the first occurrence of a substring within a string.

=== Syntax

----
string seek search → post match pre true (if found)
                   → string false (if not found)
----

=== Stack Effects

.Before
[cols="1,3"]
|===
| Level | Object

| 1
| `string` (string to search in)

| 0
| `seek` (substring to find)
|===

.After (if match found)
[cols="1,3"]
|===
| Level | Object

| 3
| `true`

| 2
| `pre` (portion before match)

| 1
| `match` (matching substring)

| 0
| `post` (portion after match)
|===

.After (if not found)
[cols="1,3"]
|===
| Level | Object

| 1
| `false`

| 0
| `string` (original, unchanged)
|===

=== Description

link:/docs/commands/references/search/[`search`] looks for the first occurrence of _seek_ within _string_.

If found, it splits _string_ into three segments:
* _pre_: portion before the match
* _match_: portion matching _seek_
* _post_: remainder after the match

All three substrings share intervals of the original string value.

If not found, it returns the original _string_ and `false`.

=== PostScript Level

*Level 1* and later

=== Examples

.Finding substring at start
[source,postscript]
----
(abbc) (ab) search
% Result: (bc) (ab) () true
% pre is empty because match at start
----

.Finding substring in middle
[source,postscript]
----
(abbc) (bb) search
% Result: (c) (bb) (a) true
----

.Finding substring at end
[source,postscript]
----
(abbc) (bc) search
% Result: () (bc) (ab) true
% post is empty because match at end
----

.No match - case sensitive
[source,postscript]
----
(abbc) (B) search
% Result: (abbc) false
----

=== Common Use Cases

==== String Parsing

[source,postscript]
----
line (:) search {
  exch pop exch pop  % Keep only post
} {
  pop  % No delimiter found
} ifelse
----

==== Text Replacement

[source,postscript]
----
text (old) search {
  % Found at position
  pre (new) post
  % Concatenate: pre + new + post
} {
  pop % text unchanged
} ifelse
----

==== Pattern Detection

[source,postscript]
----
input (ERROR) search {
  pop pop pop
  true  % Error detected
} {
  pop
  false  % No error
} ifelse
----

=== Common Pitfalls

WARNING: *Case Sensitive* - The search is exact, including case.

[source,postscript]
----
(Hello) (hello) search  % false - case mismatch
----

WARNING: *Finds Only First Match* - Stops at the first occurrence, not all occurrences.

[source,postscript]
----
(abcabc) (ab) search  % Finds first 'ab' only
----

WARNING: *Stack Order* - Results are post, match, pre (reversed from read order).

[source,postscript]
----
(hello) (ll) search  % true pre match post
% Actually: true (he) (ll) (o)
----

TIP: *Use anchorsearch for Prefixes* - If you only need to check the start of a string, link:/docs/commands/references/anchorsearch/[`anchorsearch`] is simpler.

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`invalidaccess`]
| String has no-access attribute

| [`stackoverflow`]
| Not enough room on stack for results

| [`stackunderflow`]
| Fewer than 2 operands on stack

| [`typecheck`]
| Either operand is not a string
|===

=== Implementation Notes

* Returns substrings that share the original string value
* Search is performed byte-by-byte
* Efficient for small search patterns
* Empty _seek_ always matches at position 0

=== Performance Considerations

* Linear search - O(n*m) worst case
* Fast for typical use cases
* For repeated searches, consider preprocessing
* Finding all occurrences requires loops

=== Advanced Example

.Finding all occurrences
[source,postscript]
----
/findall {  % string pattern => array-of-positions
  [
  3 1 roll  % [ string pattern
  0         % [ string pattern position
  {
    2 copy search {
      % [ ... string pattern pos post match pre true
      pop pop                % [ ... string pattern pos post
      3 index length         % [ ... string pattern pos post len
      4 index length sub     % [ ... string pattern pos post (string.len - post.len)
      4 -1 roll pop          % [ ... string pattern (string.len - post.len) pos
      add                    % [ ... string pattern new-pos
      dup                    % [ ... string pattern pos pos
      4 -1 roll exch         % [ ... pos string pattern pos
    } {
      pop exit               % [ ... string pattern pos
    } ifelse
  } loop
  pop pop pop                % [ positions...
  ]
} def

(the cat and the dog) (the) findall  % [0 13]
----

=== See Also

* link:/docs/commands/references/anchorsearch/[`anchorsearch`] - Test for prefix match
* link:/docs/commands/references/token/[`token`] - Parse token from string
* link:/docs/commands/references/getinterval/[`getinterval`] - Extract substring