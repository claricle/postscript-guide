---
layout: default
title: abs
parent: Arithmetic and Math
grand_parent: Command Reference
nav_order: 7
permalink: /commands/arithmetic-math/abs/
---
= abs

Returns the absolute value (magnitude) of a number.

== Description

The `abs` operator pops a number from the operand stack and pushes its absolute value back onto the stack. The type of the result is the same as the type of the operand, unless the operand is the most negative integer (-2147483648), in which case the result is a real.

This is a Level 1 operator, available in all PostScript implementations.

== Syntax

[source,postscript]
----
num1 abs num2
----

=== Stack Effect

.Before Execution
[cols="1,3"]
|===
|Position |Content

|Top
|`num1` (integer or real) - Number to get absolute value of
|===

.After Execution
[cols="1,3"]
|===
|Position |Content

|Top
|`num2` (integer or real) - Absolute value of num1
|===

== Parameters

`num1`:: Any number (integer or real), positive, negative, or zero

== Return Values

`num2`:: The absolute value of num1:
* Same type as num1 (integer or real)
* Exception: Most negative integer returns real

== Examples

=== Basic Usage

[source,postscript]
----
% Positive numbers unchanged
5 abs          % → 5
4.5 abs        % → 4.5

% Negative numbers become positive
-3 abs         % → 3
-4.5 abs       % → 4.5

% Zero unchanged
0 abs          % → 0
-0.0 abs       % → 0.0
----

=== Distance Calculation

[source,postscript]
----
% Distance between two points (1D)
/distance {  % x1 x2 -> dist
    sub abs
} def

10 3 distance  % → 7
3 10 distance  % → 7 (always positive)
----

=== Range Validation

[source,postscript]
----
% Check if value is within tolerance
/withinTolerance {  % value target tolerance -> bool
    3 -1 roll sub abs  % |value - target|
    le                 % <= tolerance?
} def

5.1 5.0 0.2 withinTolerance  % → true
5.3 5.0 0.2 withinTolerance  % → false
----

=== Magnitude Comparison

[source,postscript]
----
% Compare magnitudes regardless of sign
/absCmp {  % num1 num2 -> -1|0|1
    % Returns -1 if |num1| < |num2|
    %          0 if |num1| = |num2|
    %          1 if |num1| > |num2|
    exch abs exch abs  % |num1| |num2|
    2 copy eq {
        pop pop 0
    } {
        lt { -1 } { 1 } ifelse
    } ifelse
} def

-5 3 absCmp    % → 1 (|-5| > |3|)
3 -5 absCmp    % → -1 (|3| < |-5|)
----

== Advanced Examples

=== Vector Magnitude (2D)

[source,postscript]
----
/vectorMagnitude {  % [x y] -> magnitude
    aload pop           % x y
    dup mul exch        % y² x
    dup mul add         % y² + x²
    sqrt                % √(x² + y²)
} def

[3 4] vectorMagnitude  % → 5.0
----

=== Normalize to Range

[source,postscript]
----
% Clamp value to range by absolute distance
/clampSymmetric {  % value limit -> clamped
    % Clamp value to [-limit, +limit]
    exch dup abs       % limit value |value|
    2 index gt {       % If |value| > limit
        pop            % limit value
        dup 0 lt {     % If value < 0
            neg        % -limit
        } if           % else +limit
    } {
        exch pop       % value (within range)
    } ifelse
} def

150 100 clampSymmetric  % → 100
-150 100 clampSymmetric % → -100
50 100 clampSymmetric   % → 50
----

=== Maximum Absolute Value

[source,postscript]
----
% Find element with largest absolute value
/maxAbs {  % [num1 num2 ... numn] -> num
    dup 0 get abs         % Initial max magnitude
    exch                  % maxMag array
    dup 0 get             % maxMag array firstValue
    3 1 roll              % firstValue maxMag array
    {
        dup abs           % ... value |value|
        2 index gt {      % If |value| > maxMag
            exch pop      % value maxMag
            dup abs       % value |value|
            exch          % |value| value
        } {
            pop           % Keep current max
        } ifelse
    } forall
    exch pop              % Return value with max magnitude
} def

[3 -7 5 -2] maxAbs  % → -7
----

=== Difference Comparison

[source,postscript]
----
% Check if two values are approximately equal
/approxEqual {  % num1 num2 epsilon -> bool
    3 -1 roll sub abs  % epsilon |num1-num2|
    exch               % |num1-num2| epsilon
    le                 % Is difference <= epsilon?
} def

0.1 0.2 add 0.3 0.0001 approxEqual  % → true
----

== Edge Cases and Common Pitfalls

WARNING: Most negative integer (-2147483648) returns a real number.

=== Most Negative Integer

[source,postscript]
----
% Special case: most negative 32-bit integer
-2147483648 abs  % → 2147483648.0 (real!)

% This is because positive equivalent exceeds integer range
% All other integers preserve type
-2147483647 abs  % → 2147483647 (still integer)
----

=== Zero Handling

[source,postscript]
----
% Zero has no sign in integers
0 abs          % → 0

% Real zero may preserve sign (implementation dependent)
-0.0 abs       % → 0.0 or -0.0
----

=== Type Preservation

[source,postscript]
----
% Type is preserved
-5 abs         % → 5 (integer)
-5.0 abs       % → 5.0 (real)

% Unless overflow
-2147483648 abs % → 2147483648.0 (real)
----

== Type Requirements

The operand must be numeric (integer or real). Other types will cause a `typecheck` error:

[source,postscript]
----
% BAD: Non-numeric operands
(hello) abs    % ERROR: typecheck
[1 2] abs      % ERROR: typecheck
----

== Related Commands

* xref:neg.adoc[`neg`] - Negate a number
* xref:add.adoc[`add`] - Add two numbers
* xref:sub.adoc[`sub`] - Subtract two numbers
* xref:sqrt.adoc[`sqrt`] - Square root

== PostScript Level

*Available in*: PostScript Level 1 and higher

This is a fundamental arithmetic operator available in all PostScript implementations.

== Error Conditions

`stackunderflow`::
The operand stack is empty.
+
[source,postscript]
----
abs            % ERROR: stackunderflow (need 1 operand)
----

`typecheck`::
The operand is not a number.
+
[source,postscript]
----
(text) abs     % ERROR: typecheck
----

== Performance Considerations

The `abs` operator is extremely fast:

* Implemented as a simple sign check and negation
* O(1) constant time complexity
* No overhead for positive numbers in some implementations

== Best Practices

1. **Use for distance and magnitude** calculations
2. **Understand type preservation** - maintains integer/real type
3. **Remember special case** for most negative integer
4. **Combine with comparisons** for magnitude-based logic

=== Common Patterns

[source,postscript]
----
% Get sign of number
/sign {  % num -> -1|0|1
    dup 0 eq {
        pop 0
    } {
        dup 0 lt { pop -1 } { pop 1 } ifelse
    } ifelse
} def

% Ensure positive
/ensurePositive {  % num -> positiveNum
    abs
} def

% Maximum magnitude
/maxMagnitude {  % num1 num2 -> maxNum
    2 copy abs exch abs gt {
        exch
    } if
    pop
} def

-10 7 maxMagnitude  % → -10
----

=== Safe Absolute Difference

[source,postscript]
----
% Absolute difference between two numbers
/absDiff {  % num1 num2 -> diff
    sub abs
} def

10 3 absDiff   % → 7
3 10 absDiff   % → 7 (same result)
-5 5 absDiff   % → 10
----

== See Also

* xref:index.adoc[Arithmetic and Math] - All arithmetic operators
* xref:../../levels/index.adoc[PostScript Language Levels]
* https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf[PostScript Language Reference Manual] - Official specification

---

[.text-small]
_This page is part of the xref:../index.adoc[PostScript Language Reference Guide]._