---
layout: default
title: rectstroke
parent: Painting
grand_parent: Command Reference
nav_order: 13
---

== rectstroke

Strokes one or more rectangles with current line parameters.

=== Syntax

----
x y width height rectstroke → -
x y width height matrix rectstroke → -
numarray rectstroke → -
numarray matrix rectstroke → -
numstring rectstroke → -
numstring matrix rectstroke → -
----

=== Stack Effects

.First form (single rectangle)
[cols="1,3"]
|===
| Level | Object

| 3
| `height` (number)

| 2
| `width` (number)

| 1
| `y` (number)

| 0
| `x` (number)
|===

.Second form (single rectangle with matrix)
[cols="1,3"]
|===
| Level | Object

| 4
| `matrix` (array)

| 3
| `height` (number)

| 2
| `width` (number)

| 1
| `y` (number)

| 0
| `x` (number)
|===

.Third/Fifth forms (array/string)
[cols="1,3"]
|===
| Level | Object

| 0
| `numarray` or `numstring`
|===

.Fourth/Sixth forms (array/string with matrix)
[cols="1,3"]
|===
| Level | Object

| 1
| `matrix` (array)

| 0
| `numarray` or `numstring`
|===

.After (all forms)
[cols="1,3"]
|===
| Level | Object

| (empty)
| No results
|===

=== Description

xref:../rectstroke.adoc[`rectstroke`] strokes a path consisting of one or more rectangles the operands describe. In the first two forms, the operands are four numbers that describe a single rectangle. In the remaining forms, the operand is an array or an encoded number string that describes an arbitrary number of rectangles.

xref:../rectstroke.adoc[`rectstroke`] neither reads nor alters the current path in the graphics state.

If the matrix operand is present, xref:../rectstroke.adoc[`rectstroke`] concatenates matrix to the CTM after defining the path, but before stroking it. The matrix applies to the line width and dash pattern, if any, but not to the path itself.

In the first two forms, assuming width and height are positive, xref:../rectstroke.adoc[`rectstroke`] is equivalent to:

[source,postscript]
----
gsave
newpath
x y moveto
width 0 rlineto
0 height rlineto
width neg 0 rlineto
closepath
matrix concat  % If matrix operand is supplied
stroke
grestore
----

=== PostScript Level

*Level 2* and later

=== Examples

.Stroking a single rectangle
[source,postscript]
----
2 setlinewidth
100 100 80 60 rectstroke
----

.Stroking multiple rectangles
[source,postscript]
----
1 setlinewidth
[
  50 50 40 40
  100 100 60 60
  200 150 80 50
] rectstroke
----

.Using matrix for uniform line width
[source,postscript]
----
% Non-uniform scale
3 1 scale

2 setlinewidth

% Compensate for scale
50 50 60 40
[0.333 0 0 1 0 0]  % Inverse of x scale
rectstroke  % Uniform line width
----

=== Common Use Cases

==== Drawing Borders

[source,postscript]
----
/drawBorders {
  1 setlinewidth
  0 setgray
  [
    10 10 100 80
    120 10 100 80
    230 10 100 80
  ] rectstroke
} def

drawBorders
----

==== Grid Lines

[source,postscript]
----
/drawGrid {
  % spacing count drawGrid
  /count exch def
  /spacing exch def

  0.5 setlinewidth
  0.7 setgray

  /rects count 2 mul 4 mul array def
  /idx 0 def

  % Vertical lines
  0 1 count {
    spacing mul
    dup 0 spacing count mul spacing
    rects idx 3 2 roll put
    rects idx 1 add 3 2 roll put
    rects idx 2 add 3 2 roll put
    rects idx 3 add 3 2 roll put
    /idx idx 4 add def
  } for

  rects rectstroke
} def

20 10 drawGrid
----

==== Frame Drawing

[source,postscript]
----
/drawFrame {
  % x y width height thickness drawFrame
  /t exch def
  /h exch def
  /w exch def
  /y exch def
  /x exch def

  t setlinewidth
  x y w h rectstroke
} def

50 50 200 150 5 drawFrame
----

==== Nested Rectangles

[source,postscript]
----
1 setlinewidth

% Multiple concentric rectangles
10 {
  dup 10 mul  % offset
  dup 50 add  % x
  dup 50 add  % y
  200 3 index 2 mul sub  % width
  150 3 index 2 mul sub  % height
  rectstroke
  pop
} repeat
----

=== Common Pitfalls

WARNING: *Current Path Unaffected* - xref:../rectstroke.adoc[`rectstroke`] does not modify the current path.

[source,postscript]
----
newpath
50 50 moveto
100 100 lineto

100 100 50 50 rectstroke
% Original path still exists
----

WARNING: *Matrix Affects Line Width, Not Path* - The optional matrix parameter affects stroke rendering, not rectangle coordinates.

[source,postscript]
----
% Wrong understanding
100 100 50 50
[2 0 0 2 0 0]  % This does NOT scale the rectangle
rectstroke       % Only affects line width

% Correct: matrix compensates for CTM scaling
2 1 scale        % Scale CTM
100 100 50 50
[0.5 0 0 1 0 0]  % Inverse scale for uniform line
rectstroke
----

WARNING: *Array Must Have Quadruples* - Array length must be a multiple of 4.

[source,postscript]
----
% Wrong
[100 100 50] rectstroke  % Error

% Correct
[100 100 50 50] rectstroke
----

TIP: *Use Matrix for Non-Uniform Scaling* - When CTM has non-uniform scale, use matrix for consistent line appearance:

[source,postscript]
----
2 1 scale  % Non-uniform

2 setlinewidth
100 100 60 40
[0.5 0 0 1 0 0]  % Compensate
rectstroke  % Uniform 2-point line
----

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`limitcheck`]
| Too many rectangles or coordinates

| [`rangecheck`]
| Invalid matrix

| [`stackunderflow`]
| Insufficient operands on stack

| [`typecheck`]
| Operands are not numbers, valid array/string, or matrix
|===

=== Implementation Notes

* xref:../rectstroke.adoc[`rectstroke`] is optimized for efficiency
* Multiple rectangles are stroked as a single operation
* The operation is enclosed in implicit gsave/grestore
* Rectangles can overlap without issue
* Matrix parameter allows compensation for CTM scaling
* All current line parameters are applied

=== Graphics State Parameters

xref:../rectstroke.adoc[`rectstroke`] uses these parameters:

* Line width - from xref:../graphics-state/setlinewidth.adoc[`setlinewidth`]
* Line cap - from xref:../graphics-state/setlinecap.adoc[`setlinecap`]
* Line join - from xref:../graphics-state/setlinejoin.adoc[`setlinejoin`]
* Miter limit - from xref:../graphics-state/setmiterlimit.adoc[`setmiterlimit`]
* Dash pattern - from xref:../graphics-state/setdash.adoc[`setdash`]
* Current color and color space
* Current clipping path
* Current transformation matrix (CTM)

xref:../rectstroke.adoc[`rectstroke`] does not affect:

* Current path - Completely isolated
* Any graphics state parameters
* Graphics state stack

=== Line Parameter Effects

.Line Width
[source,postscript]
----
% Different widths
1 setlinewidth
100 50 60 40 rectstroke

3 setlinewidth
200 50 60 40 rectstroke

5 setlinewidth
300 50 60 40 rectstroke
----

.Line Join at Corners
[source,postscript]
----
10 setlinewidth

% Miter join (0)
0 setlinejoin
100 200 60 60 rectstroke

% Round join (1)
1 setlinejoin
200 200 60 60 rectstroke

% Bevel join (2)
2 setlinejoin
300 200 60 60 rectstroke
----

.Dash Pattern
[source,postscript]
----
[5 3] 0 setdash
2 setlinewidth
[
  50 50 80 60
  150 50 80 60
  250 50 80 60
] rectstroke

[] 0 setdash  % Reset
----

=== Best Practices

==== Set Line Parameters First

[source,postscript]
----
% Set all parameters before stroking
2 setlinewidth
1 setlinecap
1 setlinejoin
0 setgray

% Then stroke
100 100 80 60 rectstroke
----

==== Use for Multiple Rectangles

[source,postscript]
----
% Efficient: single operation
2 setlinewidth
[
  10 10 50 50
  70 10 50 50
  130 10 50 50
] rectstroke

% Less efficient: separate operations
2 setlinewidth
10 10 50 50 rectstroke
70 10 50 50 rectstroke
130 10 50 50 rectstroke
----

==== Combine Fill and Stroke

[source,postscript]
----
% Fill then stroke
0.8 setgray
100 100 80 60 rectfill

0 setgray
2 setlinewidth
100 100 80 60 rectstroke
----

==== Use Matrix for CTM Compensation

[source,postscript]
----
% Save original matrix
matrix currentmatrix /origMatrix exch def

% Apply non-uniform scale
3 1 scale

% Stroke with compensation
2 setlinewidth
100 100 60 40
[0.333 0 0 1 0 0]
rectstroke

% Restore
origMatrix setmatrix
----

=== Performance Considerations

* xref:../rectstroke.adoc[`rectstroke`] is highly optimized
* Significantly faster than manual path construction
* Multiple rectangles in one operation are more efficient
* Matrix parameter adds minimal overhead
* No path construction overhead
* Dashed lines are slower than solid lines
* Wide lines are slower than thin lines

=== Comparison with Traditional Stroke

.Traditional approach
[source,postscript]
----
gsave
  2 setlinewidth
  newpath
  100 100 moveto
  50 0 rlineto
  0 50 rlineto
  -50 0 rlineto
  closepath
  stroke
grestore
----

.rectstroke approach
[source,postscript]
----
2 setlinewidth
100 100 50 50 rectstroke
----

Benefits of xref:../rectstroke.adoc[`rectstroke`]:

* More concise syntax
* Faster execution
* No path construction overhead
* Automatic state isolation
* Can handle multiple rectangles efficiently
* Optional matrix for CTM compensation

=== Advanced Techniques

==== Button Border with Inset

[source,postscript]
----
/drawButton {
  % x y width height drawButton
  /h exch def
  /w exch def
  /y exch def
  /x exch def

  % Fill
  0.9 setgray
  x y w h rectfill

  % Outer border
  0.3 setgray
  1 setlinewidth
  x y w h rectstroke

  % Inner border (inset)
  0.6 setgray
  x 2 add y 2 add w 4 sub h 4 sub rectstroke
} def

100 100 120 40 drawButton
----

==== Table Grid

[source,postscript]
----
/drawTable {
  % x y cellW cellH cols rows drawTable
  /rows exch def
  /cols exch def
  /cellH exch def
  /cellW exch def
  /y0 exch def
  /x0 exch def

  0.5 setlinewidth
  0 setgray

  /rects rows 1 add cols 1 add add 4 mul array def
  /idx 0 def

  % Horizontal lines
  0 1 rows {
    /row exch def
    rects idx x0 put
    rects idx 1 add y0 row cellH mul add put
    rects idx 2 add cellW cols mul put
    rects idx 3 add 0 put
    /idx idx 4 add def
  } for

  % Vertical lines
  0 1 cols {
    /col exch def
    rects idx x0 col cellW mul add put
    rects idx 1 add y0 put
    rects idx 2 add 0 put
    rects idx 3 add cellH rows mul put
    /idx idx 4 add def
  } for

  rects rectstroke
} def

50 50 60 40 4 3 drawTable
----

==== Zoom Box Indicator

[source,postscript]
----
/drawZoomBox {
  % x y width height drawZoomBox
  % Dashed outline
  [4 2] 0 setdash
  1 setlinewidth
  0 setgray

  4 copy rectstroke

  % Solid handles at corners
  [] 0 setdash
  3 setlinewidth

  % Corner handles (8x8)
  [
    5 index 4 sub 4 index 4 sub 8 8  % LL
    4 index 4 sub 3 index 4 sub 8 8  % LR
    5 index 4 sub 2 index 4 sub 8 8  % UL
    3 index 4 sub 1 index 4 sub 8 8  % UR
  ] rectstroke

  pop pop pop pop
} def

100 100 120 80 drawZoomBox
----

=== Common Pitfalls

WARNING: *Current Path Unaffected* - xref:../rectstroke.adoc[`rectstroke`] does not modify the current path.

[source,postscript]
----
newpath
50 50 moveto
100 100 lineto

100 100 50 50 rectstroke
% Original path unchanged
----

WARNING: *Matrix Parameter Affects Stroke, Not Coordinates* - The matrix affects line rendering, not rectangle position.

[source,postscript]
----
% Matrix does NOT move/scale the rectangle
100 100 50 50
[2 0 0 2 0 0]  % Affects line width only
rectstroke       % Rectangle at same position
----

WARNING: *Graphics State Must Be Set First* - Set line parameters before calling xref:../rectstroke.adoc[`rectstroke`].

[source,postscript]
----
% Wrong order
100 100 50 50 rectstroke
2 setlinewidth  % Too late!

% Correct order
2 setlinewidth
100 100 50 50 rectstroke
----

TIP: *Use Matrix for Uniform Lines Under Scaling* - When CTM has non-uniform scaling, use matrix to maintain consistent line appearance:

[source,postscript]
----
2 1 scale  % Non-uniform scale

2 setlinewidth
100 100 60 40
[0.5 0 0 1 0 0]  % Inverse of x scale
rectstroke  % Uniform 2-point line
----

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`limitcheck`]
| Too many rectangles or coordinates

| [`rangecheck`]
| Invalid matrix

| [`stackunderflow`]
| Insufficient operands on stack

| [`typecheck`]
| Operands are not numbers, valid array/string, or matrix
|===

=== Implementation Notes

* xref:../rectstroke.adoc[`rectstroke`] is optimized for efficiency
* Multiple rectangles are stroked as a single operation
* The operation is enclosed in implicit gsave/grestore
* All current line parameters are applied
* Matrix parameter allows compensation for CTM scaling
* Corners use current line join setting

=== Graphics State Parameters

All stroke-related parameters affect xref:../rectstroke.adoc[`rectstroke`]:

* **Line width** - Thickness of stroked lines
* **Line cap** - Appearance of rectangle corners (with line join)
* **Line join** - How corners are rendered
* **Miter limit** - Controls miter join behavior
* **Dash pattern** - Solid or dashed lines
* **Current color** - Color of stroked lines
* **CTM** - Transforms rectangles and affects line width
* **Clipping path** - Clips the stroke output

=== Line Join at Rectangle Corners

[source,postscript]
----
15 setlinewidth

% Miter join (0) - sharp corners
0 setlinejoin
50 200 80 60 rectstroke

% Round join (1) - rounded corners
1 setlinejoin
200 200 80 60 rectstroke

% Bevel join (2) - beveled corners
2 setlinejoin
350 200 80 60 rectstroke
----

=== Best Practices

==== Set All Line Parameters

[source,postscript]
----
% Complete line setup
2 setlinewidth
1 setlinecap
1 setlinejoin
10 setmiterlimit
[] 0 setdash
0 setgray

% Then stroke
100 100 80 60 rectstroke
----

==== Use for Efficient Multi-Rectangle Operations

[source,postscript]
----
% Build array of rectangles
/rects 100 4 mul array def
0 1 99 {
  /i exch def
  rects i 4 mul i 10 mod 60 mul 10 add put
  rects i 4 mul 1 add i 10 idiv 60 mul 10 add put
  rects i 4 mul 2 add 50 put
  rects i 4 mul 3 add 50 put
} for

1 setlinewidth
rects rectstroke
----

==== Combine with rectfill

[source,postscript]
----
% Draw filled and stroked rectangles
/drawBox {
  % x y width height drawBox
  % Fill
  0.8 setgray
  4 copy rectfill

  % Stroke
  0 setgray
  2 setlinewidth
  rectstroke
} def

100 100 80 60 drawBox
----

==== Use Matrix for Consistent Lines

[source,postscript]
----
/uniformRectstroke {
  % x y w h sx sy uniformRectstroke
  /sy exch def
  /sx exch def
  [1 sx div 0 0 1 sy div 0 0]
  rectstroke
} def

3 1 scale  % Non-uniform scale
100 100 60 40 3 1 uniformRectstroke
----

=== Performance Considerations

* xref:../rectstroke.adoc[`rectstroke`] is highly optimized
* Much faster than manual path construction
* Multiple rectangles are more efficient than separate operations
* Matrix parameter adds minimal overhead
* Dashed lines are slower than solid
* Wide lines are slower than thin lines
* Simple miter joins are fastest

=== Advanced Techniques

==== Double-Border Effect

[source,postscript]
----
/doubleBorder {
  % x y width height doubleBorder
  % Outer border
  0 setgray
  4 setlinewidth
  4 copy rectstroke

  % Inner border
  1 setgray
  2 setlinewidth
  rectstroke
} def

100 100 120 80 doubleBorder
----

==== Selection Marquee

[source,postscript]
----
/drawMarquee {
  % x y width height drawMarquee
  % Outer line
  1 setgray
  2 setlinewidth
  4 copy rectstroke

  % Inner dashed line
  0 setgray
  1 setlinewidth
  [4 4] 0 setdash
  rectstroke

  [] 0 setdash
} def

150 150 100 80 drawMarquee
----

==== Wireframe Grid

[source,postscript]
----
/drawWireframe {
  % spacing count drawWireframe
  /count exch def
  /s exch def

  0.3 setgray
  0.5 setlinewidth

  count count mul {
    rand s count mul mod
    rand s count mul mod
    s s rectstroke
  } repeat
} def

25 10 drawWireframe
----

=== See Also

* xref:../stroke.adoc[`stroke`] - Stroke arbitrary path
* xref:../rectfill.adoc[`rectfill`] - Fill rectangles (Level 2)
* xref:../rectclip.adoc[`rectclip`] - Clip to rectangles (Level 2)
* xref:../ustroke.adoc[`ustroke`] - Stroke user path (Level 2)
* xref:../graphics-state/setlinewidth.adoc[`setlinewidth`] - Set line width
* xref:../graphics-state/setlinecap.adoc[`setlinecap`] - Set line cap
* xref:../graphics-state/setlinejoin.adoc[`setlinejoin`] - Set line join
* xref:../graphics-state/setmiterlimit.adoc[`setmiterlimit`] - Set miter limit
* xref:../graphics-state/setdash.adoc[`setdash`] - Set dash pattern
* xref:../path-construction/newpath.adoc[`newpath`] - Clear current path