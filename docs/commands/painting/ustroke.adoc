---
layout: default
title: ustroke
parent: Painting
grand_parent: Command Reference
nav_order: 7
---

== ustroke

Interprets a user path definition and strokes the resulting path.

=== Syntax

----
userpath ustroke → -
userpath matrix ustroke → -
----

=== Stack Effects

.First form (no matrix)
[cols="1,3"]
|===
| Level | Object

| 0
| `userpath` (array, packed array, or string)
|===

.Second form (with matrix)
[cols="1,3"]
|===
| Level | Object

| 1
| `matrix` (array)

| 0
| `userpath` (array, packed array, or string)
|===

.After (both forms)
[cols="1,3"]
|===
| Level | Object

| (empty)
| No results
|===

=== Description

xref:../ustroke.adoc[`ustroke`] interprets a user path definition and strokes the resulting path as if by xref:../stroke.adoc[`stroke`]. The entire operation is effectively enclosed by xref:../graphics-state/gsave.adoc[`gsave`] and xref:../graphics-state/grestore.adoc[`grestore`], so xref:../ustroke.adoc[`ustroke`] has no lasting effect on the graphics state.

In the first form (with no matrix operand), xref:../ustroke.adoc[`ustroke`] is equivalent to:

[source,postscript]
----
gsave newpath uappend stroke grestore
----

In the second form, xref:../ustroke.adoc[`ustroke`] concatenates `matrix` to the CTM after interpreting `userpath`, but before executing xref:../stroke.adoc[`stroke`]. The matrix applies to the line width and the dash pattern, if any, but not to the path itself. This form is equivalent to:

[source,postscript]
----
gsave
newpath
exch uappend     % Interpret userpath
concat           % Concat matrix to CTM
stroke
grestore
----

The main use of the second form is to compensate for variations in line width and dash pattern that occur if the CTM has been scaled by different amounts in x and y.

=== PostScript Level

*Level 2* and later

=== Examples

.Simple user path stroke
[source,postscript]
----
[
  50 50 250 250 setbbox
  100 100 moveto
  200 100 lineto
  200 200 lineto
  100 200 lineto
  closepath
] ustroke
----

.User path with line parameters
[source,postscript]
----
5 setlinewidth
1 setlinecap
1 setlinejoin

[
  ucache
  50 50 250 250 setbbox
  100 150 moveto
  200 150 lineto
] ustroke
----

.Using matrix for uniform line width
[source,postscript]
----
% Scale coordinate system
2 1 scale  % x scaled by 2

% Compensate in stroke
[
  0 0 100 100 setbbox
  10 50 moveto
  90 50 lineto
]
[0.5 0 0 1 0 0]  % Inverse of x scaling
ustroke  % Line appears uniform width
----

=== Common Use Cases

==== Efficient Repeated Strokes

[source,postscript]
----
/linePath [
  ucache
  0 0 200 10 setbbox
  10 5 moveto
  190 5 lineto
] def

% Draw multiple strokes efficiently
2 setlinewidth
0 1 9 {
  linePath ustroke
  0 20 translate
} for
----

==== Dashed User Path Stroke

[source,postscript]
----
[5 3] 0 setdash
3 setlinewidth

[
  ucache
  50 50 250 250 setbbox
  100 100 moveto
  200 100 lineto
  200 200 lineto
  100 200 lineto
  closepath
] ustroke

[] 0 setdash  % Reset
----

==== Compensating for Scaled CTM

[source,postscript]
----
% Non-uniform scale
3 1 scale

/boxPath [
  0 0 100 100 setbbox
  10 10 moveto
  90 10 lineto
  90 90 lineto
  10 90 lineto
  closepath
] def

2 setlinewidth

% Without compensation - line appears 3x wider horizontally
boxPath ustroke

% With compensation - uniform line width
boxPath
[0.333 0 0 1 0 0]  % Inverse of x scale
ustroke
----

=== Common Pitfalls

WARNING: *Graphics State Not Modified* - xref:../ustroke.adoc[`ustroke`] automatically saves and restores graphics state.

[source,postscript]
----
2 setlinewidth
[
  0 0 100 100 setbbox
  10 10 moveto
  90 90 lineto
] ustroke
% Line width still 2, path is empty
----

WARNING: *Matrix Affects Line Width, Not Path* - The optional matrix parameter affects stroke rendering, not path coordinates.

[source,postscript]
----
% Wrong interpretation
[
  0 0 100 100 setbbox
  50 50 moveto
  100 50 lineto
]
[2 0 0 2 0 0]  % This does NOT scale the path
ustroke  % Path position unchanged, only line rendering affected
----

WARNING: *Must Include setbbox* - User paths require `setbbox`.

[source,postscript]
----
% Wrong - no setbbox
[
  100 100 moveto
  200 200 lineto
] ustroke  % Error: rangecheck

% Correct
[
  50 50 250 250 setbbox
  100 100 moveto
  200 200 lineto
] ustroke
----

TIP: *Use Matrix for Uniform Strokes Under Scaling* - When CTM has non-uniform scaling, use matrix to maintain consistent line appearance:

[source,postscript]
----
/uniformStroke {
  % userpath sx sy uniformStroke
  /sy exch def
  /sx exch def
  [1 sx div 0 0 1 sy div 0 0]
  ustroke
} def

2 1 scale  % Non-uniform scale
/myPath [
  0 0 100 100 setbbox
  50 50 moveto
  90 50 lineto
] def

myPath 2 1 uniformStroke  % Compensates for scale
----

=== Error Conditions

[cols="1,3"]
|===
| Error | Condition

| [`invalidaccess`]
| User path array is not executable or has insufficient access

| [`limitcheck`]
| Path becomes too complex for implementation

| [`rangecheck`]
| User path is malformed (missing setbbox, coordinates out of bounds, invalid matrix)

| [`stackunderflow`]
| Insufficient operands on stack

| [`typecheck`]
| Operand is not a valid user path or matrix
|===

=== Implementation Notes

* User paths provide efficient stroke rendering
* Cached user paths (with `ucache`) improve performance for reuse
* The bounding box enables rendering optimization
* Matrix parameter allows compensation for CTM scaling
* Very complex paths may exceed implementation limits

=== Graphics State Interaction

xref:../ustroke.adoc[`ustroke`] uses these graphics state parameters:

* Line width - from xref:../graphics-state/setlinewidth.adoc[`setlinewidth`]
* Line cap - from xref:../graphics-state/setlinecap.adoc[`setlinecap`]
* Line join - from xref:../graphics-state/setlinejoin.adoc[`setlinejoin`]
* Miter limit - from xref:../graphics-state/setmiterlimit.adoc[`setmiterlimit`]
* Dash pattern - from xref:../graphics-state/setdash.adoc[`setdash`]
* Current color
* Current clipping path
* Current transformation matrix (CTM)

The graphics state is automatically saved before and restored after the operation.

=== Comparison with Traditional Stroke

.Traditional stroke approach
[source,postscript]
----
gsave
newpath
100 100 moveto
200 100 lineto
200 200 lineto
closepath

2 setlinewidth
stroke
grestore
----

.User path approach (xref:../ustroke.adoc[`ustroke`])
[source,postscript]
----
2 setlinewidth
[
  50 50 250 250 setbbox
  100 100 moveto
  200 100 lineto
  200 200 lineto
  closepath
] ustroke
----

Benefits of user paths:

* More compact representation
* Can be cached for efficiency
* Automatic graphics state management
* Optional matrix for stroke compensation

=== Best Practices

==== Set Line Parameters Before ustroke

[source,postscript]
----
% Set all stroke parameters first
3 setlinewidth
1 setlinecap
1 setlinejoin
[5 3] 0 setdash

% Then stroke user path
[
  0 0 100 100 setbbox
  10 50 moveto
  90 50 lineto
] ustroke
----

==== Use ucache for Repeated Paths

[source,postscript]
----
/borderPath [
  ucache  % Cache for reuse
  0 0 120 80 setbbox
  5 5 moveto
  115 5 lineto
  115 75 lineto
  5 75 lineto
  closepath
] def

% Efficient reuse
2 setlinewidth
10 {
  borderPath ustroke
  0 90 translate
} repeat
----

==== Compensate for Non-Uniform Scaling

[source,postscript]
----
% When CTM has non-uniform scale
currentmatrix                    % Save original CTM
2 1 scale                        % Non-uniform scale

/path [
  0 0 100 50 setbbox
  50 25 moveto
  90 25 lineto
] def

% Calculate inverse scale matrix
[0.5 0 0 1 0 0]                  % Inverse of 2,1 scale
path exch ustroke                % Uniform line width

setmatrix                        % Restore CTM
----

==== Combine with Other User Path Operations

[source,postscript]
----
/shapePath [
  ucache
  0 0 100 100 setbbox
  50 50 40 0 360 arc
  closepath
] def

% Fill
0.8 setgray
shapePath ufill

% Stroke
0 setgray
2 setlinewidth
shapePath ustroke
----

=== Performance Considerations

* User paths are generally faster than traditional path construction
* Cached user paths (`ucache`) provide significant performance improvement
* Matrix parameter adds minimal overhead
* Dashed lines are slower than solid lines
* Wide lines are slower than thin lines
* Complex paths with many segments take longer

=== See Also

* xref:../stroke.adoc[`stroke`] - Traditional stroke operator
* xref:../ufill.adoc[`ufill`] - Fill user path
* xref:../ustrokepath.adoc[`ustrokepath`] - Convert user path stroke to outline
* xref:../strokepath.adoc[`strokepath`] - Convert stroke to outline path
* `setbbox` - Set bounding box
* `ucache` - Enable user path caching
* `uappend` - Append user path to current path
* xref:../graphics-state/setlinewidth.adoc[`setlinewidth`] - Set line width
* xref:../graphics-state/setlinecap.adoc[`setlinecap`] - Set line cap
* xref:../graphics-state/setlinejoin.adoc[`setlinejoin`] - Set line join
* xref:../graphics-state/setdash.adoc[`setdash`] - Set dash pattern
* xref:../graphics-state/gsave.adoc[`gsave`] - Save graphics state
* xref:../graphics-state/grestore.adoc[`grestore`] - Restore graphics state