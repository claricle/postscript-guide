---
layout: default
title: clippath
parent: Painting
grand_parent: Command Reference
nav_order: 11
---

== clippath

Sets the current path to the current clipping path.

=== Syntax

----
- clippath â†’ -
----

=== Stack Effects

.Before
[cols="1,3"]
|===
| Level | Object

| (empty)
| No operands required
|===

.After
[cols="1,3"]
|===
| Level | Object

| (empty)
| No results (current path is set)
|===

=== Description

link:clippath.adoc[`clippath`] sets the current path to one that describes the current clipping path. This operator is useful for determining the exact extent of the imaging area on the current output device.

If the current clipping path is the result of application of the xref:clip.adoc[`clip`] or xref:eoclip.adoc[`eoclip`] operator, the path set by link:clippath.adoc[`clippath`] is generally suitable only for filling or clipping. It is not suitable for stroking because it may contain interior segments or disconnected subpaths produced by the clipping process.

The path returned by link:clippath.adoc[`clippath`] describes the clipping region as it exists in user space coordinates, transformed through the current transformation matrix (CTM).

=== PostScript Level

*Level 1* and later

=== Examples

.Getting the current clip bounds
[source,postscript]
----
clippath
pathbbox  % Returns llx lly urx ury
% Now know the bounding box of clip region
----

.Erasing within the clip region
[source,postscript]
----
clippath
1 setgray
fill      % Erase (fill with white) the clip area
----

.Stroking the clip boundary
[source,postscript]
----
gsave
  clippath
  2 setlinewidth
  0 setgray
  stroke  % Draw border around clip region
grestore
----

=== Common Use Cases

==== Determining Available Drawing Area

[source,postscript]
----
/getClipBounds {
  % Returns: llx lly urx ury
  clippath
  pathbbox
} def

getClipBounds
% Stack: llx lly urx ury
----

==== Clearing the Clipped Area

[source,postscript]
----
/clearClip {
  % Fill clip region with white
  gsave
    clippath
    1 setgray
    fill
  grestore
} def

clearClip
----

==== Drawing Clip Region Border

[source,postscript]
----
/showClipBorder {
  % Draw visible border of clip
  gsave
    clippath
    0 setgray
    1 setlinewidth
    stroke
  grestore
} def

showClipBorder
----

==== Inverting the Clip Region

[source,postscript]
----
/invertClip {
  % Fill everything outside clip
  gsave
    % Get clip bounds
    clippath pathbbox
    /ury exch def
    /urx exch def
    /lly exch def
    /llx exch def

    % Create inverse path
    newpath
    % Large outer rectangle
    llx 1000 sub lly 1000 sub moveto
    urx 1000 add lly 1000 sub lineto
    urx 1000 add ury 1000 add lineto
    llx 1000 sub ury 1000 add lineto
    closepath

    % Subtract clip region
    clippath

    % Fill with even-odd
    eofill
  grestore
} def
----

=== Common Pitfalls

WARNING: *Result May Not Be Suitable for Stroking* - If the clip was created with xref:clip.adoc[`clip`] or xref:eoclip.adoc[`eoclip`], the path may have interior segments.

[source,postscript]
----
% After complex clip operation
clip
newpath

clippath
stroke  % May show unexpected interior lines

% Better for filling or getting bounds
clippath
fill    % Suitable use
----

WARNING: *Path Is in User Space* - The clip path is transformed to current user space coordinates.

[source,postscript]
----
% After scaling
2 2 scale

clippath  % Returns coordinates in scaled space
pathbbox  % Bounds reflect current CTM
----

WARNING: *Replaces Current Path* - link:clippath.adoc[`clippath`] replaces any existing current path.

[source,postscript]
----
newpath
100 100 moveto
200 200 lineto

clippath  % Previous path is lost
----

TIP: *Use for Bounds Checking* - link:clippath.adoc[`clippath`] with `pathbbox` gives exact drawable area:

[source,postscript]
----
clippath
pathbbox
/height exch 3 index sub def
/width exch 3 index sub def
pop pop  % Remove llx lly
% width and height now available
----

=== Error Conditions

None. link:clippath.adoc[`clippath`] cannot generate errors.

=== Implementation Notes

* The path set by link:clippath.adoc[`clippath`] may be complex if multiple clip operations were performed
* The path accurately represents the intersection of all previous clip operations
* The path is always closed and suitable for filling
* Device-default clip paths are typically rectangular
* The path is transformed to user space via the inverse CTM

=== Interaction with Graphics State

link:clippath.adoc[`clippath`] is affected by:

* Current clipping path - This is what gets returned
* Current transformation matrix (CTM) - Path is returned in user space

link:clippath.adoc[`clippath`] affects:

* Current path - Replaced with the clip path
* Nothing else in graphics state

=== Best Practices

==== Save/Restore Around Use

[source,postscript]
----
gsave
  clippath
  % Use clip path
  % ...
grestore
% Original path restored
----

==== Use for Page Setup

[source,postscript]
----
% At document start, get page bounds
clippath
pathbbox
/pageHeight exch 3 index sub def
/pageWidth exch 3 index sub def
/pageBottom exch def
/pageLeft exch def

% Use throughout document
% ...
----

==== Combine with pathbbox

[source,postscript]
----
/getDrawingArea {
  % Returns: width height
  clippath
  pathbbox
  % Stack: llx lly urx ury
  exch 3 index sub  % height
  3 1 roll
  exch sub          % width
  exch
} def

getDrawingArea
% Stack: width height
----

=== Advanced Techniques

==== Centering Content in Clip Region

[source,postscript]
----
/centerInClip {
  % contentWidth contentHeight centerInClip -> x y
  /ch exch def
  /cw exch def

  clippath pathbbox
  /ury exch def
  /urx exch def
  /lly exch def
  /llx exch def

  % Calculate center position
  llx urx add 2 div cw 2 div sub
  lly ury add 2 div ch 2 div sub
} def

% Usage:
100 50 centerInClip  % Center 100x50 content
% Stack: x y
----

==== Tiling Within Clip Region

[source,postscript]
----
/tileInClip {
  % tileWidth tileHeight proc tileInClip
  /proc exch def
  /th exch def
  /tw exch def

  clippath pathbbox
  /ury exch def
  /urx exch def
  /lly exch def
  /llx exch def

  lly th ury {
    /y exch def
    llx tw urx {
      /x exch def
      gsave
        x y translate
        proc exec
      grestore
    } for
  } for
} def
----

==== Creating Margin Guides

[source,postscript]
----
/drawMargins {
  % margin drawMargins - draws margin guides
  /m exch def

  clippath pathbbox
  /ury exch def
  /urx exch def
  /lly exch def
  /llx exch def

  gsave
    [3 3] 0 setdash
    0.5 setgray
    0.5 setlinewidth

    newpath
    llx m add lly m add moveto
    urx m sub lly m add lineto
    urx m sub ury m sub lineto
    llx m add ury m sub lineto
    closepath
    stroke
  grestore
} def

20 drawMargins  % 20-point margins
----

=== Performance Considerations

* link:clippath.adoc[`clippath`] is a fast operation
* The complexity of the returned path depends on clipping history
* Very complex clipping paths may result in large path structures
* Using `pathbbox` after link:clippath.adoc[`clippath`] is efficient for bounds checking
* No rendering is performed by link:clippath.adoc[`clippath`] itself

=== Common Patterns

.Get clip dimensions
[source,postscript]
----
clippath pathbbox
3 index sub /height exch def
2 index sub /width exch def
pop pop
----

.Fill clip with color
[source,postscript]
----
0.9 setgray
clippath fill
----

.Test if point in clip
[source,postscript]
----
/inClip {
  % x y inClip -> bool
  gsave
    clippath
    infill  % or ineofill depending on clip
  grestore
} def
----

=== See Also

* xref:clip.adoc[`clip`] - Set clipping path (non-zero winding)
* xref:eoclip.adoc[`eoclip`] - Set clipping path (even-odd rule)
* `initclip` - Reset to device default
* `rectclip` - Clip to rectangles (Level 2)
* `pathbbox` - Get path bounding box
* `infill` - Test if point inside path
* xref:../graphics-state/gsave.adoc[`gsave`] - Save graphics state
* xref:../graphics-state/grestore.adoc[`grestore`] - Restore graphics state
* xref:../path-construction/newpath.adoc[`newpath`] - Clear current path