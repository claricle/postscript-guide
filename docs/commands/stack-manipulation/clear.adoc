---
layout: default
title: clear
parent: Stack Manipulation
grand_parent: Command Reference
nav_order: 8
---
= clear

Removes all elements from the operand stack, leaving it empty.

== Description

The `clear` operator pops all objects from the operand stack and discards them, regardless of how many elements are present. After execution, the stack is guaranteed to be empty.

This is a drastic operation that should be used carefully, as it discards all stack contents without any possibility of recovery. It's primarily useful for error recovery, initialization, or resetting to a known state.

This is a Level 1 operator, available in all PostScript implementations.

== Syntax

[source,postscript]
----
any1 ... anyn clear -
----

=== Stack Effect

.Before Execution
[cols="1,3"]
|===
|Position |Content

|Any depth
|`any1 ... anyn` - Any number of elements (possibly already empty)
|===

.After Execution
[cols="1,3"]
|===
|Position |Content

|
|_(Stack is empty)_
|===

== Parameters

None. `clear` operates on the entire stack regardless of its current state.

== Return Values

None. The stack is empty after `clear` executes.

== Examples

=== Basic Usage

[source,postscript]
----
% Clear a stack with elements
1 2 3 4 5 clear
count               % Stack: 0

% Clear an already empty stack (safe)
clear
clear               % Still empty, no error
----

=== Using in Error Recovery

[source,postscript]
----
% Reset stack after error
{
    % Some operation that might fail
    1 0 div
} stopped {
    % Error occurred, clean up
    clear
    (Error recovered, stack cleared) print
} if
----

=== Initialization Pattern

[source,postscript]
----
% Start with known empty state
clear
% Now build exactly what we need
100 200 300
count               % Stack: 100 200 300 3
----

=== Comparing with Selective Removal

[source,postscript]
----
% clear vs multiple pops
1 2 3 4 5

% Using clear
clear               % Stack: (empty)

% Using pop (would need 5 pops)
1 2 3 4 5
pop pop pop pop pop % Stack: (empty)
% clear is simpler and safer!
----

== Advanced Examples

=== Safe Procedure Wrapper

[source,postscript]
----
% Execute procedure with stack isolation
/isolatedExec {     % proc -> (executes with clean stack)
    count array astore  % Save current stack
    exch exec           % Execute with cleared stack
    exch aload pop      % Restore saved stack
} def

% Usage
1 2 3
{ clear 10 20 add } isolatedExec
% Stack: 1 2 3 (preserved, isolated exec returned nothing)
----

=== Conditional Clear

[source,postscript]
----
% Clear only if stack has elements
/clearIfNotEmpty {
    count 0 gt {
        clear
    } if
} def

clear
clearIfNotEmpty     % Does nothing (already empty)
1 2 3
clearIfNotEmpty     % Clears the stack
----

=== Clear and Initialize

[source,postscript]
----
% Clear and set up initial state
/reset {
    clear
    % Set up initial values
    0 0 moveto
    1 setlinewidth
    0 setgray
} def
----

=== Stack Depth Verification

[source,postscript]
----
% Clear and verify
/safeClear {
    clear
    count 0 ne {
        (Warning: stack not empty after clear!) print
    } {
        (Stack successfully cleared) print
    } ifelse
} def
----

== Edge Cases and Common Pitfalls

WARNING: `clear` discards all stack elements without any confirmation or undo capability. Use with caution in production code.

=== Accidental Data Loss

[source,postscript]
----
% BAD: Losing important data
/importantValue 42 def
importantValue
% ... some operations ...
clear               % OOPS! Lost the value
% importantValue is gone from stack

% GOOD: Save important values first
/importantValue 42 def
importantValue
/saved exch def     % Save before clearing
clear
saved               % Restore after clear
----

=== Clear vs cleartomark

[source,postscript]
----
% clear removes EVERYTHING
mark 1 2 3 4 5 clear
count               % Stack: 0 (mark is gone too!)

% cleartomark removes up to and including mark
mark 1 2 3 4 5 cleartomark
count               % Stack: 0 (but stops at mark)

% cleartomark preserves elements below mark
10 20 mark 1 2 3 cleartomark
count               % Stack: 10 20 2
----

=== Clear Doesn't Affect Other Stacks

[source,postscript]
----
% clear only affects operand stack
% Dictionary stack and execution stack unchanged

/mydict 10 dict def
mydict begin
    /value 42 def
end

1 2 3 clear         % Operand stack cleared
mydict /value get   % Stack: 42 (dictionary unaffected)
----

TIP: Consider using xref:cleartomark.adoc[`cleartomark`] instead of `clear` when you want to preserve elements below a certain point on the stack.

=== No Error on Empty Stack

[source,postscript]
----
% clear never causes an error
clear
clear
clear               % All safe, even on empty stack
count               % Stack: 0
----

== Related Commands

* xref:pop.adoc[`pop`] - Remove single element
* xref:cleartomark.adoc[`cleartomark`] - Remove elements up to a mark
* xref:count.adoc[`count`] - Check if stack is empty
* xref:mark.adoc[`mark`] - Place marker for selective clearing

== PostScript Level

*Available in*: PostScript Level 1 and higher

This is a fundamental operator available in all PostScript implementations.

== Error Conditions

None. `clear` never generates an error, even when executed on an empty stack.

== Performance Considerations

The `clear` operator is very fast with O(n) time complexity where n is the number of elements on the stack. However, since it's typically used with small to moderate stack depths, performance is rarely a concern.

Clearing is faster than individually popping each element.

== Best Practices

1. **Use sparingly**: Only clear when you truly need to discard all stack contents
2. **Consider alternatives**: Use xref:pop.adoc[`pop`] for selective removal or xref:cleartomark.adoc[`cleartomark`] for bounded clearing
3. **Error recovery**: Excellent for recovering from errors and resetting to known state
4. **Document intent**: Always comment why you're clearing the stack
5. **Test carefully**: Ensure you're not accidentally discarding needed data

=== Good Use Cases

[source,postscript]
----
% 1. Error recovery
{
    % Complex operation
} stopped {
    clear   % Clean up on error
} if

% 2. Interactive session reset
/reset {
    clear
    initgraphics
    initmatrix
} def

% 3. Test isolation
/runTest {
    clear           % Start with clean stack
    % Run test
    clear           % Clean up after
} def
----

=== Anti-Patterns to Avoid

[source,postscript]
----
% BAD: Using clear when you know stack depth
1 2 3
clear               % Wasteful, use: pop pop pop

% BAD: Clear in middle of calculations
10 20
clear               % Lost the values!
% ... now what?

% GOOD: Plan stack usage
10 20
add                 % Use the values
----

== See Also

* xref:../../syntax/operators.adoc[Operators Overview] - Understanding PostScript operators
* xref:../../usage/basic/stack-operations.adoc[Stack Operations Guide] - Stack manipulation tutorial
* xref:../../usage/error-handling.adoc[Error Handling] - Using clear for error recovery
* xref:index.adoc[Stack Manipulation] - All stack operators
* https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf[PostScript Language Reference Manual] - Official specification (page 337)

---

[.text-small]
_This page is part of the xref:../index.adoc[PostScript Language Reference Guide]._