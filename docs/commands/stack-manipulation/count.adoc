---
layout: default
title: count
parent: Stack Manipulation
grand_parent: Command Reference
nav_order: 7
permalink: /commands/stack-manipulation/count/
---
= count
:description: Count the number of elements on the operand stack
:keywords: postscript, stack, count, depth, size

[.lead]
Counts the number of elements on the operand stack and pushes this count onto the stack.

== Description

The `count` operator returns the current depth of the operand stack as an integer. This is useful for stack management, debugging, and implementing stack-aware operations.

After execution, the stack contains one more element than before (the count itself), so the count value reflects the stack depth *before* `count` was executed.

This is a Level 1 operator, available in all PostScript implementations.

== Syntax

[source,postscript]
----
any1 ... anyn count any1 ... anyn n
----

=== Stack Effect

.Before Execution
[cols="1,3"]
|===
|Position |Content

|Top to Bottom
|`any1 ... anyn` - Any number of elements (possibly zero)
|===

.After Execution
[cols="1,3"]
|===
|Position |Content

|Top
|`n` (integer) - Number of elements that were on stack

|Top-1 to Top-n
|`any1 ... anyn` - Original elements (unchanged)
|===

== Parameters

None. `count` takes no operands from the stack.

== Return Values

Returns a non-negative integer representing the number of elements that were on the stack before `count` was executed.

== Examples

=== Basic Usage

[source,postscript]
----
% Empty stack
clear count         % Stack: 0

% Stack with elements
clear 1 2 3 count   % Stack: 1 2 3 3

% After count, stack has one more element
clear 1 2 count     % Stack: 1 2 2
count               % Stack: 1 2 2 3
----

=== Checking Stack Depth

[source,postscript]
----
% Verify sufficient elements before operation
count 3 ge {
    % At least 3 elements, safe to proceed
    3 array astore pop
} {
    (Insufficient elements on stack) print
} ifelse
----

=== Stack Debugging

[source,postscript]
----
% Print current stack depth
/showDepth {
    count (Stack depth: ) print =
} def

clear
showDepth           % Prints: Stack depth: 0
1 2 3
showDepth           % Prints: Stack depth: 3
----

=== Preserving Stack State

[source,postscript]
----
% Save stack depth before operation
count               % Remember initial depth
% ... perform operations that may change stack ...
count exch sub      % Calculate elements added/removed
----

== Advanced Examples

=== Implementing cleartomark Safely

[source,postscript]
----
% Count elements before finding mark
/safeCountToMark {
    count mark exch
    % Find mark position
    0 1 2 index 1 sub {
        index type /marktype eq {
            exch pop exit
        } {
            pop
        } ifelse
    } for
} def
----

=== Stack Depth Assertions

[source,postscript]
----
% Assert exact stack depth
/assertDepth {      % ... expected -> ... (or error)
    count 1 sub     % Get actual depth (excluding expected)
    1 index ne {
        (Stack depth mismatch!) print
        count =
    } {
        pop
    } ifelse
} def

% Usage
clear 1 2 3
3 assertDepth       % OK
4 assertDepth       % Prints error
----

=== Clearing to Specific Depth

[source,postscript]
----
% Pop elements until stack has desired depth
/popToDepth {       % ... targetDepth -> ...
    {
        count 1 index le {
            pop exit
        } {
            exch pop
        } ifelse
    } loop
} def

1 2 3 4 5 6 7 8 9 10
3 popToDepth        % Stack: 1 2 3
----

=== Stack Monitoring

[source,postscript]
----
% Monitor stack growth during procedure
/monitorStack {     % proc -> result (with stack report)
    count exch      % initial_count proc
    exec            % Execute procedure
    count           % final_count
    (Stack grew by: ) print
    exch sub =
} def

% Usage
{ 1 2 3 } monitorStack      % Prints: Stack grew by: 3
----

== Edge Cases and Common Pitfalls

WARNING: Remember that `count` itself adds one element to the stack, so count after count increases by 1 each time.

=== Count Adds to Stack

[source,postscript]
----
% CAUTION: count modifies the stack
clear
count               % Stack: 0
count               % Stack: 0 1 (not 0 0!)
count               % Stack: 0 1 2
----

=== Using Count in Conditionals

[source,postscript]
----
% GOOD: Use count result immediately
count 0 eq {
    (Stack is empty) print
} if

% BAD: Don't save count then test
count /depth exch def
depth 0 eq {        % depth value is stale if stack changed!
    (May not be empty) print
} if
----

=== Count Includes All Elements

[source,postscript]
----
% Count includes marks and all other elements
clear
mark 1 2 3
count               % Stack: mark 1 2 3 4
% All 4 elements counted (including mark)
----

TIP: Use `count` immediately before the operation that needs to know stack depth. Don't store the count value for later use, as the stack may change.

== Related Commands

* xref:counttomark.adoc[`counttomark`] - Count elements until a mark
* xref:clear.adoc[`clear`] - Remove all elements from stack
* xref:pop.adoc[`pop`] - Remove single element
* xref:copy.adoc[`copy`] - Copy n elements
* xref:roll.adoc[`roll`] - Rotate n elements

== PostScript Level

*Available in*: PostScript Level 1 and higher

This is a fundamental operator available in all PostScript implementations.

== Error Conditions

`stackoverflow`::
The stack is at maximum capacity and cannot accommodate the count value. This is extremely rare in practice.
+
[source,postscript]
----
% (Only possible if stack nearly full)
----

== Performance Considerations

The `count` operator is extremely fast with O(1) constant time complexity. The interpreter maintains a running count of stack elements, so this operation doesn't need to traverse the stack.

Use `count` freely for debugging and stack management without performance concerns.

== Best Practices

1. **Use for safety checks**: Always verify stack depth before operations that require specific numbers of elements
2. **Immediate use**: Use the count value immediately; don't store it for later
3. **Debugging aid**: Excellent for understanding stack behavior during development
4. **Combine with copy**: Use `count` to determine how many elements to copy
5. **Document assumptions**: When procedures assume certain stack depths, document and verify with `count`

=== Safe Procedure Patterns

[source,postscript]
----
% Check prerequisites before operation
/safeOperation {    % a b c -> result
    % Require exactly 3 arguments
    count 3 lt {
        (Error: safeOperation requires 3 arguments) print
        quit
    } if

    % Perform operation knowing we have enough elements
    add add
} def

% Usage
1 2 safeOperation       % Prints error
1 2 3 safeOperation     % Returns 6
----

=== Stack State Verification

[source,postscript]
----
% Verify procedure maintains stack balance
/testStackBalance {  % proc -> (reports balance)
    count           % Save initial depth
    exch exec       % Execute procedure
    count           % Get final depth
    exch sub        % Calculate difference
    dup 0 ne {
        (Warning: stack imbalance: ) print =
    } {
        pop
        (Stack balanced) print
    } ifelse
} def
----

== See Also

* xref:../../syntax/operators.adoc[Operators Overview] - Understanding PostScript operators
* xref:../../usage/basic/stack-operations.adoc[Stack Operations Guide] - Stack manipulation tutorial
* xref:../../usage/debugging.adoc[Debugging Guide] - Using count for debugging
* xref:index.adoc[Stack Manipulation] - All stack operators
* https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf[PostScript Language Reference Manual] - Official specification (page 378)

---

[.text-small]
_This page is part of the xref:../index.adoc[PostScript Language Reference Guide]._